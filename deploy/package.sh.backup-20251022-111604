#!/bin/bash
set -e

# ============================================================
# KoalaqVision Docker Image Builder & Publisher
# ============================================================

# 颜色定义
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
YELLOW=$'\e[1;33m'
BLUE=$'\e[0;34m'
PURPLE=$'\e[0;35m'
CYAN=$'\e[0;36m'
WHITE=$'\e[1;37m'
NC=$'\e[0m' # No Color
BOLD=$'\e[1m'

# 配置文件
CONFIG_FILE=".package.conf"
HISTORY_FILE=".build_history"

# 默认配置
DEFAULT_DOCKERHUB_REGISTRY="775495797/koalaqvision"
DEFAULT_HARBOR_REGISTRY="six.lllama.cn:10880/koalaq-vision/koalaqvision"

# 加载配置
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    else
        DOCKERHUB_REGISTRY="$DEFAULT_DOCKERHUB_REGISTRY"
        HARBOR_REGISTRY="$DEFAULT_HARBOR_REGISTRY"
        LAST_VERSION=""
    fi
}

# 保存配置
save_config() {
    cat > "$CONFIG_FILE" << EOF
DOCKERHUB_REGISTRY="$DOCKERHUB_REGISTRY"
HARBOR_REGISTRY="$HARBOR_REGISTRY"
LAST_VERSION="$VERSION"
EOF
}

# 记录构建历史
save_history() {
    local action="$1"
    local version="$2"
    local registry="$3"
    echo "$(date '+%Y-%m-%d %H:%M:%S') | $action | $version | $registry" >> "$HISTORY_FILE"
}

# 打印标题
print_header() {
    clear
    echo -e "${CYAN}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║${WHITE}        KoalaqVision Docker Build & Publish Tool          ${CYAN}║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

# 打印分隔线
print_separator() {
    echo -e "${BLUE}────────────────────────────────────────────────────────────${NC}"
}

# 打印成功消息
print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

# 打印错误消息
print_error() {
    echo -e "${RED}✗${NC} $1"
}

# 打印警告消息
print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# 打印信息消息
print_info() {
    echo -e "${CYAN}ℹ${NC} $1"
}

# 检查 Docker
check_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed!"
        exit 1
    fi
}

# 检查 Dockerfile
check_dockerfile() {
    if [ ! -f "Dockerfile" ]; then
        print_error "Dockerfile not found!"
        print_info "This script should be run from the deploy/ directory."
        exit 1
    fi
}

# 检测系统架构
detect_architecture() {
    local arch=$(uname -m)
    case "$arch" in
        x86_64)
            echo "amd64"
            ;;
        aarch64|arm64)
            echo "arm64"
            ;;
        armv7l)
            echo "armv7"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# 获取架构标识
ARCH=$(detect_architecture)
ARCH_SUFFIX=""

# 获取本地镜像版本列表（包括带架构后缀的版本）
get_local_versions() {
    docker images --format "{{.Tag}}" "$DOCKERHUB_REGISTRY" 2>/dev/null | grep -v "latest" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+(-[a-z0-9]+)?$" | sort -V -r || true
}

# 显示本地镜像
show_local_images() {
    print_header
    echo -e "${BOLD}Local Built Images:${NC}"
    print_separator

    local versions=$(get_local_versions)
    if [ -z "$versions" ]; then
        print_warning "No local images found"
    else
        echo -e "${CYAN}Registry:${NC} $DOCKERHUB_REGISTRY"
        echo ""
        printf "${BOLD}%-15s %-20s %-15s${NC}\n" "VERSION" "IMAGE ID" "SIZE"
        print_separator

        while read -r version; do
            if [ -n "$version" ]; then
                local image_info=$(docker images --format "{{.ID}} {{.Size}}" "$DOCKERHUB_REGISTRY:$version" 2>/dev/null)
                local image_id=$(echo "$image_info" | awk '{print $1}')
                local image_size=$(echo "$image_info" | awk '{print $2}')
                printf "%-15s %-20s %-15s\n" "$version" "${image_id:0:12}" "$image_size"
            fi
        done <<< "$versions"

        echo ""
        local latest_id=$(docker images --format "{{.ID}}" "$DOCKERHUB_REGISTRY:latest" 2>/dev/null)
        if [ -n "$latest_id" ]; then
            print_info "Latest tag points to: ${latest_id:0:12}"
        fi
    fi

    echo ""
}

# 显示构建历史
show_build_history() {
    print_header
    echo -e "${BOLD}Build & Push History:${NC}"
    print_separator

    if [ ! -f "$HISTORY_FILE" ] || [ ! -s "$HISTORY_FILE" ]; then
        print_warning "No build history found"
    else
        printf "${BOLD}%-20s %-10s %-15s %-30s${NC}\n" "DATE TIME" "ACTION" "VERSION" "REGISTRY"
        print_separator
        tail -20 "$HISTORY_FILE" | while IFS='|' read -r datetime action version registry; do
            datetime=$(echo "$datetime" | xargs)
            action=$(echo "$action" | xargs)
            version=$(echo "$version" | xargs)
            registry=$(echo "$registry" | xargs)

            case "$action" in
                BUILD)
                    action_colored="${GREEN}$action${NC}"
                    ;;
                PUSH-HUB)
                    action_colored="${BLUE}$action${NC}"
                    ;;
                PUSH-HARBOR)
                    action_colored="${PURPLE}$action${NC}"
                    ;;
                *)
                    action_colored="$action"
                    ;;
            esac

            printf "%-20s %-20s %-15s %-30s\n" "$datetime" "$(echo -e $action_colored)" "$version" "$registry"
        done
    fi

    echo ""
}

# 更新 docker-compose 文件中的镜像版本
update_compose_files() {
    local version="$1"
    local updated_count=0

    print_separator
    print_info "Updating docker-compose files..."
    echo ""

    # 更新 docker-compose.yml (Docker Hub)
    if [ -f "docker-compose.yml" ]; then
        # 匹配 775495797/koalaqvision:版本号 的模式
        if sed -i.bak "s|775495797/koalaqvision:[0-9\.]*|775495797/koalaqvision:$version|g" docker-compose.yml; then
            print_success "Updated docker-compose.yml → 775495797/koalaqvision:$version"
            rm -f docker-compose.yml.bak
            ((updated_count++))
        fi
    fi

    # 更新 docker-compose-cn.yml (Harbor)
    if [ -f "docker-compose-cn.yml" ]; then
        # 提取 Harbor 仓库地址
        local harbor_image=$(echo "$HARBOR_REGISTRY" | sed 's|/koalaqvision$||')
        if sed -i.bak "s|${harbor_image}/koalaqvision:[0-9\.]*|${harbor_image}/koalaqvision:$version|g" docker-compose-cn.yml; then
            print_success "Updated docker-compose-cn.yml → ${harbor_image}/koalaqvision:$version"
            rm -f docker-compose-cn.yml.bak
            ((updated_count++))
        fi
    fi

    # 更新 docker-compose-release.yml (如果存在)
    if [ -f "docker-compose-release.yml" ]; then
        if sed -i.bak "s|775495797/koalaqvision:[0-9\.]*|775495797/koalaqvision:$version|g" docker-compose-release.yml; then
            print_success "Updated docker-compose-release.yml → 775495797/koalaqvision:$version"
            rm -f docker-compose-release.yml.bak
            ((updated_count++))
        fi
    fi

    if [ "$updated_count" -gt 0 ]; then
        echo ""
        print_success "Updated $updated_count compose file(s) to version $version"
    else
        print_warning "No compose files were updated"
    fi
}

# 建议版本号
suggest_version() {
    local last_version=$(get_local_versions | head -1)

    if [ -z "$last_version" ] && [ -n "$LAST_VERSION" ]; then
        last_version="$LAST_VERSION"
    fi

    if [ -z "$last_version" ]; then
        echo "0.1.0"
    else
        # 去掉架构后缀（如果有）
        local version_base=$(echo "$last_version" | sed 's/-[a-z0-9]*$//')
        local major=$(echo "$version_base" | cut -d. -f1)
        local minor=$(echo "$version_base" | cut -d. -f2)
        local patch=$(echo "$version_base" | cut -d. -f3)

        patch=$((patch + 1))
        echo "$major.$minor.$patch"
    fi
}

# 输入版本号
input_version() {
    local suggested=$(suggest_version)

    echo ""
    print_info "Current architecture: ${YELLOW}${ARCH}${NC}"
    print_info "Last version: ${YELLOW}$(get_local_versions | head -1 || echo 'None')${NC}"
    print_info "Suggested version: ${GREEN}$suggested${NC}"
    echo ""

    while true; do
        read -p "$(echo -e ${CYAN}Enter version [${GREEN}$suggested${CYAN}]: ${NC})" VERSION

        if [ -z "$VERSION" ]; then
            VERSION="$suggested"
        fi

        if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            break
        else
            print_error "Invalid version format! Use X.Y.Z (e.g., 0.1.0)"
        fi
    done

    # 选择构建方式
    echo ""
    print_info "Select build method:"
    echo -e "  ${GREEN}1)${NC} Docker Buildx - Multi-arch build (one tag supports both amd64/arm64)"
    echo -e "  ${GREEN}2)${NC} Native build with arch suffix - Build for ${ARCH} only, tag as ${VERSION}-${ARCH}"
    echo -e "  ${GREEN}3)${NC} Native build without arch suffix - Build for ${ARCH} only, tag as ${VERSION}"
    echo ""
    read -p "$(echo -e ${CYAN}Select build method [${GREEN}1${CYAN}]: ${NC})" build_method

    if [ -z "$build_method" ]; then
        build_method="1"
    fi

    BUILD_METHOD="$build_method"
    case "$build_method" in
        1)
            VERSION_TAG="${VERSION}"
            USE_BUILDX=true
            ARCH_SUFFIX=""
            print_info "Using Docker Buildx for multi-architecture build"
            ;;
        2)
            ARCH_SUFFIX="-${ARCH}"
            VERSION_TAG="${VERSION}${ARCH_SUFFIX}"
            USE_BUILDX=false
            print_info "Using native build with arch suffix: ${GREEN}${VERSION_TAG}${NC}"
            ;;
        3)
            VERSION_TAG="${VERSION}"
            ARCH_SUFFIX=""
            USE_BUILDX=false
            print_warning "Using native build without arch suffix (may conflict with other architectures)"
            ;;
        *)
            print_error "Invalid option, using Buildx"
            VERSION_TAG="${VERSION}"
            USE_BUILDX=true
            ARCH_SUFFIX=""
            ;;
    esac
}

# 配置 Docker Hub 仓库
configure_dockerhub() {
    print_header
    echo -e "${BOLD}Configure Docker Hub Registry${NC}"
    print_separator
    echo ""
    print_info "Current registry: ${YELLOW}$DOCKERHUB_REGISTRY${NC}"
    echo ""

    read -p "$(echo -e ${CYAN}Enter Docker Hub registry [${GREEN}$DOCKERHUB_REGISTRY${CYAN}]: ${NC})" new_registry

    if [ -n "$new_registry" ]; then
        DOCKERHUB_REGISTRY="$new_registry"
        save_config
        print_success "Docker Hub registry updated to: $DOCKERHUB_REGISTRY"
    else
        print_info "Keeping current registry"
    fi

    echo ""
    read -p "Press Enter to continue..."
}

# 配置 Harbor 仓库
configure_harbor() {
    print_header
    echo -e "${BOLD}Configure Harbor Registry${NC}"
    print_separator
    echo ""
    print_info "Current registry: ${YELLOW}$HARBOR_REGISTRY${NC}"
    echo ""

    read -p "$(echo -e ${CYAN}Enter Harbor registry [${GREEN}$HARBOR_REGISTRY${CYAN}]: ${NC})" new_registry

    if [ -n "$new_registry" ]; then
        HARBOR_REGISTRY="$new_registry"
        save_config
        print_success "Harbor registry updated to: $HARBOR_REGISTRY"
    else
        print_info "Keeping current registry"
    fi

    echo ""
    read -p "Press Enter to continue..."
}

# 构建镜像
build_image() {
    print_header
    echo -e "${BOLD}Build Docker Image${NC}"
    print_separator

    input_version

    echo ""
    print_info "Building image..."
    print_info "Version: ${YELLOW}$VERSION${NC}"
    print_info "Tag: ${YELLOW}$VERSION_TAG${NC}"
    print_info "Registry: ${YELLOW}$DOCKERHUB_REGISTRY${NC}"

    if [ "$USE_BUILDX" = true ]; then
        print_info "Build method: ${YELLOW}Docker Buildx (multi-arch)${NC}"
        echo ""
        print_info "Target platforms:"
        echo -e "  ${GREEN}•${NC} linux/amd64"
        echo -e "  ${GREEN}•${NC} linux/arm64"
    else
        print_info "Build method: ${YELLOW}Native build${NC}"
        print_info "Architecture: ${YELLOW}$ARCH${NC}"
    fi

    print_separator
    echo ""

    # 使用 Buildx 构建多架构镜像
    if [ "$USE_BUILDX" = true ]; then
        print_info "Checking Docker Buildx..."

        # 检查 buildx 是否可用
        if ! docker buildx version &> /dev/null; then
            print_error "Docker Buildx is not available!"
            print_info "Please install Docker 19.03+ with buildx support"
            echo ""
            read -p "Press Enter to continue..."
            return 1
        fi

        # 创建或使用 builder
        print_info "Setting up buildx builder..."
        if ! docker buildx inspect multiarch-builder &> /dev/null; then
            docker buildx create --name multiarch-builder --use
            print_success "Created buildx builder: multiarch-builder"
        else
            docker buildx use multiarch-builder
            print_info "Using existing builder: multiarch-builder"
        fi

        echo ""
        print_info "Starting multi-architecture build..."
        print_warning "This may take a while (building for both amd64 and arm64)..."
        echo ""

        # 构建并推送多架构镜像（buildx 需要同时推送）
        print_info "This build will automatically push to registry"
        echo ""
        read -p "$(echo -e ${YELLOW}Continue? [y/N]: ${NC})" confirm

        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            print_info "Build cancelled"
            echo ""
            read -p "Press Enter to continue..."
            return
        fi

        docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --file Dockerfile \
            --tag "$DOCKERHUB_REGISTRY:$VERSION_TAG" \
            --tag "$DOCKERHUB_REGISTRY:latest" \
            --push \
            ..

        echo ""
        print_separator
        print_success "Multi-architecture build and push completed!"
        print_separator
        echo ""
        print_info "Images created (2 tags, each supports amd64 + arm64):"
        echo -e "  ${GREEN}•${NC} $DOCKERHUB_REGISTRY:$VERSION_TAG"
        echo -e "  ${GREEN}•${NC} $DOCKERHUB_REGISTRY:latest"
        echo ""
        print_info "View at: ${BLUE}https://hub.docker.com/r/$DOCKERHUB_REGISTRY/tags${NC}"

        save_history "BUILD-BUILDX" "$VERSION_TAG" "$DOCKERHUB_REGISTRY (amd64+arm64)"

    # 使用原生 Docker 构建
    else
        if [ -n "$ARCH_SUFFIX" ]; then
            docker build \
                -f Dockerfile \
                -t "$DOCKERHUB_REGISTRY:$VERSION_TAG" \
                -t "$DOCKERHUB_REGISTRY:latest-$ARCH" \
                ..

            echo ""
            print_separator
            print_success "Build completed successfully!"
            print_separator
            echo ""
            print_info "Images created (2 tags):"
            echo -e "  ${GREEN}•${NC} $DOCKERHUB_REGISTRY:$VERSION_TAG"
            echo -e "  ${GREEN}•${NC} $DOCKERHUB_REGISTRY:latest-$ARCH"
            echo ""
            print_warning "Note: These tags include architecture suffix"
        else
            docker build \
                -f Dockerfile \
                -t "$DOCKERHUB_REGISTRY:$VERSION_TAG" \
                -t "$DOCKERHUB_REGISTRY:latest" \
                ..

            echo ""
            print_separator
            print_success "Build completed successfully!"
            print_separator
            echo ""
            print_info "Images created (2 tags):"
            echo -e "  ${GREEN}•${NC} $DOCKERHUB_REGISTRY:$VERSION_TAG"
            echo -e "  ${GREEN}•${NC} $DOCKERHUB_REGISTRY:latest"
        fi

        save_history "BUILD" "$VERSION_TAG" "$DOCKERHUB_REGISTRY ($ARCH)"
    fi

    echo ""
    save_config

    # 更新 docker-compose 文件
    update_compose_files "$VERSION_TAG"

    echo ""
    read -p "Press Enter to continue..."
}

# 推送到 Docker Hub
push_dockerhub() {
    print_header
    echo -e "${BOLD}Push to Docker Hub${NC}"
    print_separator

    local versions=$(get_local_versions)

    if [ -z "$versions" ]; then
        print_error "No local images found. Build an image first."
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    echo ""
    echo "${CYAN}Available versions:${NC}"
    local version_array=()
    local idx=1
    while read -r ver; do
        if [ -n "$ver" ]; then
            echo "  ${GREEN}${idx})${NC} ${ver}"
            version_array+=("$ver")
            ((idx++))
        fi
    done <<< "$versions"
    echo ""

    read -p "$(echo -e ${CYAN}Enter number or version [${GREEN}1${CYAN}]: ${NC})" input

    if [ -z "$input" ]; then
        VERSION_TAG="${version_array[0]}"
        print_info "Using latest version: $VERSION_TAG"
    elif [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -ge 1 ] && [ "$input" -le "${#version_array[@]}" ]; then
        VERSION_TAG="${version_array[$((input-1))]}"
        print_info "Selected version: $VERSION_TAG"
    else
        VERSION_TAG="$input"
        print_info "Using version: $VERSION_TAG"
    fi

    # 检测是否带架构后缀
    local has_arch_suffix=false
    if [[ "$VERSION_TAG" =~ -[a-z0-9]+$ ]]; then
        has_arch_suffix=true
        local detected_arch=$(echo "$VERSION_TAG" | grep -oE '[a-z0-9]+$')
        print_info "Detected architecture: ${YELLOW}${detected_arch}${NC}"
    fi

    echo ""
    print_info "Checking Docker login status..."

    if ! docker info | grep -q "Username"; then
        print_warning "Not logged in to Docker Hub"
        echo ""
        print_info "Please login:"
        docker login
        echo ""
    fi

    print_separator
    print_info "Pushing to Docker Hub..."
    print_separator
    echo ""

    docker push "$DOCKERHUB_REGISTRY:$VERSION_TAG"
    echo ""

    # 如果有架构后缀，推送 latest-{arch}；否则推送 latest
    if [ "$has_arch_suffix" = true ]; then
        local detected_arch=$(echo "$VERSION_TAG" | grep -oE '[a-z0-9]+$')
        print_info "Pushing latest-${detected_arch}..."
        docker push "$DOCKERHUB_REGISTRY:latest-${detected_arch}"
    else
        docker push "$DOCKERHUB_REGISTRY:latest"
    fi

    echo ""
    print_separator
    print_success "Push to Docker Hub completed!"
    print_separator
    echo ""
    print_info "View at: ${BLUE}https://hub.docker.com/r/$DOCKERHUB_REGISTRY/tags${NC}"
    echo ""

    save_history "PUSH-HUB" "$VERSION_TAG" "$DOCKERHUB_REGISTRY"

    read -p "Press Enter to continue..."
}

# 推送到 Harbor
push_harbor() {
    print_header
    echo -e "${BOLD}Push to Harbor Registry${NC}"
    print_separator

    local versions=$(get_local_versions)

    if [ -z "$versions" ]; then
        print_error "No local images found. Build an image first."
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    echo ""
    echo "${CYAN}Available versions:${NC}"
    local version_array=()
    local idx=1
    while read -r ver; do
        if [ -n "$ver" ]; then
            echo "  ${GREEN}${idx})${NC} ${ver}"
            version_array+=("$ver")
            ((idx++))
        fi
    done <<< "$versions"
    echo ""

    read -p "$(echo -e ${CYAN}Enter number or version [${GREEN}1${CYAN}]: ${NC})" input

    if [ -z "$input" ]; then
        VERSION_TAG="${version_array[0]}"
        print_info "Using latest version: $VERSION_TAG"
    elif [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -ge 1 ] && [ "$input" -le "${#version_array[@]}" ]; then
        VERSION_TAG="${version_array[$((input-1))]}"
        print_info "Selected version: $VERSION_TAG"
    else
        VERSION_TAG="$input"
        print_info "Using version: $VERSION_TAG"
    fi

    # 检测是否带架构后缀
    local has_arch_suffix=false
    if [[ "$VERSION_TAG" =~ -[a-z0-9]+$ ]]; then
        has_arch_suffix=true
        local detected_arch=$(echo "$VERSION_TAG" | grep -oE '[a-z0-9]+$')
        print_info "Detected architecture: ${YELLOW}${detected_arch}${NC}"
    fi

    echo ""
    print_info "Target Harbor: ${YELLOW}$HARBOR_REGISTRY${NC}"
    echo ""

    read -p "$(echo -e ${YELLOW}Continue? [y/N]: ${NC})" confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        print_info "Cancelled"
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    echo ""
    print_info "Checking Docker login status..."

    local harbor_host=$(echo "$HARBOR_REGISTRY" | cut -d'/' -f1)

    if ! docker login "$harbor_host" 2>&1 | grep -q "Login Succeeded\|Authenticating"; then
        print_warning "Attempting to login to Harbor..."
        echo ""
        docker login "$harbor_host"
        echo ""
    fi

    print_separator
    print_info "Tagging and pushing to Harbor..."
    print_separator
    echo ""

    print_info "Tagging $DOCKERHUB_REGISTRY:$VERSION_TAG -> $HARBOR_REGISTRY:$VERSION_TAG"
    docker tag "$DOCKERHUB_REGISTRY:$VERSION_TAG" "$HARBOR_REGISTRY:$VERSION_TAG"

    if [ "$has_arch_suffix" = true ]; then
        local detected_arch=$(echo "$VERSION_TAG" | grep -oE '[a-z0-9]+$')
        docker tag "$DOCKERHUB_REGISTRY:latest-${detected_arch}" "$HARBOR_REGISTRY:latest-${detected_arch}"
    else
        docker tag "$DOCKERHUB_REGISTRY:latest" "$HARBOR_REGISTRY:latest"
    fi

    echo ""
    print_info "Pushing $HARBOR_REGISTRY:$VERSION_TAG..."
    docker push "$HARBOR_REGISTRY:$VERSION_TAG"

    echo ""
    if [ "$has_arch_suffix" = true ]; then
        local detected_arch=$(echo "$VERSION_TAG" | grep -oE '[a-z0-9]+$')
        print_info "Pushing $HARBOR_REGISTRY:latest-${detected_arch}..."
        docker push "$HARBOR_REGISTRY:latest-${detected_arch}"
    else
        print_info "Pushing $HARBOR_REGISTRY:latest..."
        docker push "$HARBOR_REGISTRY:latest"
    fi

    echo ""
    print_separator
    print_success "Push to Harbor completed!"
    print_separator
    echo ""

    save_history "PUSH-HARBOR" "$VERSION_TAG" "$HARBOR_REGISTRY"

    read -p "Press Enter to continue..."
}

# 清理旧镜像
cleanup_images() {
    print_header
    echo -e "${BOLD}Cleanup Old Images${NC}"
    print_separator

    local versions=$(get_local_versions)

    if [ -z "$versions" ]; then
        print_warning "No local images to clean"
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    local count=$(echo "$versions" | wc -l)

    echo ""
    print_info "Found $count local image(s)"
    echo ""
    echo "${CYAN}Available versions (newest first):${NC}"
    local idx=1
    while read -r ver; do
        if [ -n "$ver" ]; then
            echo "  ${GREEN}${idx})${NC} ${ver}"
            ((idx++))
        fi
    done <<< "$versions"
    echo ""

    read -p "$(echo -e ${YELLOW}Keep how many recent versions? [${GREEN}3${YELLOW}]: ${NC})" keep_count

    if [ -z "$keep_count" ]; then
        keep_count=3
    fi

    if ! [[ "$keep_count" =~ ^[0-9]+$ ]]; then
        print_error "Invalid number"
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    local to_delete=$(echo "$versions" | tail -n +$((keep_count + 1)))

    if [ -z "$to_delete" ]; then
        print_info "No images to delete"
        echo ""
        read -p "Press Enter to continue..."
        return
    fi

    echo ""
    print_warning "The following versions will be deleted:"
    echo "$to_delete"
    echo ""

    read -p "$(echo -e ${RED}Confirm deletion? [y/N]: ${NC})" confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo ""
        while read -r version; do
            if [ -n "$version" ]; then
                print_info "Removing $DOCKERHUB_REGISTRY:$version"
                docker rmi "$DOCKERHUB_REGISTRY:$version" 2>/dev/null || true
            fi
        done <<< "$to_delete"

        echo ""
        print_success "Cleanup completed"
    else
        print_info "Cancelled"
    fi

    echo ""
    read -p "Press Enter to continue..."
}

# 主菜单
main_menu() {
    while true; do
        print_header

        echo -e "${BOLD}Main Menu${NC}"
        print_separator
        echo ""
        echo -e "  ${GREEN}1)${NC} Build Docker Image"
        echo -e "  ${BLUE}2)${NC} Push to Docker Hub"
        echo -e "  ${PURPLE}3)${NC} Push to Harbor"
        echo ""
        echo -e "  ${CYAN}4)${NC} View Local Images"
        echo -e "  ${CYAN}5)${NC} View Build History"
        echo ""
        echo -e "  ${YELLOW}6)${NC} Configure Docker Hub Registry"
        echo -e "  ${YELLOW}7)${NC} Configure Harbor Registry"
        echo ""
        echo -e "  ${RED}8)${NC} Cleanup Old Images"
        echo ""
        echo -e "  ${WHITE}0)${NC} Exit"
        echo ""
        print_separator

        read -p "$(echo -e ${CYAN}Select option: ${NC})" choice

        case $choice in
            1)
                build_image
                ;;
            2)
                push_dockerhub
                ;;
            3)
                push_harbor
                ;;
            4)
                show_local_images
                read -p "Press Enter to continue..."
                ;;
            5)
                show_build_history
                read -p "Press Enter to continue..."
                ;;
            6)
                configure_dockerhub
                ;;
            7)
                configure_harbor
                ;;
            8)
                cleanup_images
                ;;
            0)
                echo ""
                print_success "Goodbye!"
                echo ""
                exit 0
                ;;
            *)
                print_error "Invalid option"
                sleep 1
                ;;
        esac
    done
}

# ============================================================
# 入口点
# ============================================================

# 检查是否为命令行模式
if [ $# -gt 0 ]; then
    # 命令行模式（保持向后兼容）
    VERSION=""
    PUSH=false
    PUSH_HARBOR=false

    while getopts "v:r:pc" opt; do
        case $opt in
            v)
                VERSION="$OPTARG"
                ;;
            r)
                DOCKERHUB_REGISTRY="$OPTARG"
                ;;
            p)
                PUSH=true
                ;;
            c)
                PUSH_HARBOR=true
                ;;
            \?)
                echo "Usage: ./package.sh -v <version> [-r <registry>] [-p] [-c]"
                exit 1
                ;;
        esac
    done

    check_docker
    check_dockerfile
    load_config

    if [ -z "$VERSION" ]; then
        print_error "Version is required in CLI mode!"
        echo ""
        echo "Usage: ./package.sh -v <version> [-r <registry>] [-p] [-c]"
        echo ""
        echo "Or run without arguments for interactive mode:"
        echo "  ./package.sh"
        echo ""
        exit 1
    fi

    # 执行构建
    echo ""
    print_info "Building Docker image..."
    print_info "Tags: $VERSION and latest"
    echo ""

    docker build -f Dockerfile -t "$DOCKERHUB_REGISTRY:$VERSION" -t "$DOCKERHUB_REGISTRY:latest" ..

    echo ""
    print_success "Build completed: $DOCKERHUB_REGISTRY:$VERSION (2 tags created)"
    save_history "BUILD" "$VERSION" "$DOCKERHUB_REGISTRY"

    # 更新 docker-compose 文件
    update_compose_files "$VERSION"

    # 推送到 Docker Hub
    if [ "$PUSH" = true ]; then
        docker push "$DOCKERHUB_REGISTRY:$VERSION"
        docker push "$DOCKERHUB_REGISTRY:latest"
        print_success "Pushed to Docker Hub"
        save_history "PUSH-HUB" "$VERSION" "$DOCKERHUB_REGISTRY"
    fi

    # 推送到 Harbor
    if [ "$PUSH_HARBOR" = true ]; then
        docker tag "$DOCKERHUB_REGISTRY:$VERSION" "$HARBOR_REGISTRY:$VERSION"
        docker tag "$DOCKERHUB_REGISTRY:latest" "$HARBOR_REGISTRY:latest"
        docker push "$HARBOR_REGISTRY:$VERSION"
        docker push "$HARBOR_REGISTRY:latest"
        print_success "Pushed to Harbor"
        save_history "PUSH-HARBOR" "$VERSION" "$HARBOR_REGISTRY"
    fi

    save_config
else
    # 交互式模式
    check_docker
    check_dockerfile
    load_config
    main_menu
fi
